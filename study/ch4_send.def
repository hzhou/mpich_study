# include: ../common.def
# include: macros/sendrecv.def
include: macros/ch4_frame.def

subcode: mpidi_func(fn, @params)
    NEWLINE?
    $:: MPL_STATIC_INLINE_PREFIX int MPIDI_$(fn)($(params))
    {
        int mpi_errno = MPI_SUCCESS;
        MPIR_FUNC_VERBOSE_STATE_DECL(MPID_STATE_$(fn:uc));
        MPIR_FUNC_VERBOSE_ENTER(MPID_STATE_$(fn:uc));
        $(if:safe)
            int cs_acq = 0;
            MPID_THREAD_SAFE_BEGIN(VCI, MPIDI_global.vci_lock, cs_acq)

        NEWLINE
        BLOCK
        NEWLINE

        fn_exit:
        $(if:safe)
            MPID_THREAD_SAFE_END(VCI, MPIDI_global.vci_lock, cs_acq)
        MPIR_FUNC_VERBOSE_EXIT(MPID_STATE_$(fn:uc));
        return mpi_errno;

        NEWLINE
        fn_fail:
        goto fn_exit;
    }

subcode: unsafe_call(fn, @args))
    $(if:fn~[isrb]*send$)
        $(set:fn=mpi_$(fn))
    #ifdef MPIDI_CH4_DIRECT_NETMOD
    mpi_errno = MPIDI_NM_$(fn)($(args));
    #else
    int r;
    $if r = MPIDI_av_is_local(av)
        mpi_errno = MPIDI_SHM_$(fn)($(args));
    $else
        mpi_errno = MPIDI_NM_$(fn)($(args));
    #endif

    NEWLINE
    $if mpi_errno != MPI_SUCCESS
        MPIR_ERR_POP(mpi_errno)

subcode: safe_call(fn, @args)
    $if !cs_acq
        *(req) = MPIR_Request_create(MPIR_REQUEST_KIND__SEND);
        MPIR_ERR_CHKANDSTMT((*req) == NULL, mpi_errno, MPIX_ERR_NOREQ, goto fn_fail, "**nomemreq");
        MPIR_Datatype_add_ref_if_not_builtin(datatype);
        $(if:fn~.*_coll)
            $(if:fn~send)
                $(set:SEND=CSEND)
            $(else)
                $(set:SEND=ICSEND)
            MPIDI_workq_csend_enqueue($(SEND), $(arg_csend));
        $(else)
            MPIDI_workq_pt2pt_enqueue($(fn:uc), $(arg_p2p));
    $else
        (*req) = NULL
        MPIDI_workq_vci_progress_unsafe()
        mpi_errno = MPIDI_$(fn)_unsafe($(args));

subcode: mpid_call(fn, @args)
    $if unlikely(rank == MPI_PROC_NULL)
        *request = MPIR_Request_create_complete(MPIR_REQUEST_KIND__SEND)
        MPIR_ERR_CHKANDSTMT(*request==NULL, mpi_errno, MPIX_ERR_NOREQ, goto fn_fail, "**nomemreq");
        goto fn_exit;

    $my MPIDI_av_entry_t *av = NULL
    av = MPIDIU_comm_rank_to_av(comm, rank)
    mpi_errno = MPIDI_$(fn)_safe($(args), av, request);

    if mpi_errno != MPI_SUCCESS
        MPIR_ERR_POP(mpi_errno)

macros:
    arg_send:: buf, count, datatype, rank, tag, comm, context_offset, av
    arg_p2p:: buf, NULL, count, datatype, rank, tag, comm, context_offset, av, NULL, *req, NULL, NULL, NULL
    arg_csend: buf, count, datatype, rank, tag, comm, context_offset, av, *req, errflag

    unsafe_list:: send, send_coll
    unsafe_list:: isend, isend_coll
    unsafe_list:: ssend, issend

    mpid_list: send, send_coll, isend, isend_coll, rsend, irsend, ssend, issend

    preq_list: send, ssend, bsend, rsend

perlcode: set_netmod_fn
    $(set:get=MyDef::compileutil::get_macro_word)
    $(set:set=MyDef::compileutil::set_current_macro)

    my $is_safe=$(get)("safe")
    my $fn = $(get)("fn")
    my $netmod_fn = $fn
    $(set)("netmod_fn", $netmod_fn)

    my $args = $(get)("arg_send")
    $if $is_safe
        $args .= ", req"
    $else
        $args .= ", request"
    $if $fn=~/send_coll/
        $args .=", errflag"

    my %types=(
        rank=> "const void *",
        count=> "MPI_Aint",
        datatype=>"MPI_Datatype",
        rank=>"int",
        tag=>"int",
        comm=>"MPIR_Comm *",
        context_offset=>"int",
        av=>"MPIDI_av_entry_t *",
        request=>"MPIR_Request **",
        req    =>"MPIR_Request **",
        errflag=>"MPIR_Errflag_t *",
    );

    my @params
    $foreach $a in split /,\s*/, $args
        $if $types{$a}
            push @params, $types{$a}." $a"
        $else
            push @params, $a

    $(set)("args", $args)
    $(set)("params", join(', ', @params))

    $if $fn=~/_coll/

    
#---------------------------------------- 
page: ch4_send.h, ch4_h_frame
    $(for:fn in $(unsafe_list))
        $call set_netmod_fn
        &call mpidi_func, $(fn), $(params)
            $call unsafe_call, $(fn), $(args)
    $(for:fn in $(unsafe_list))
        $(set:safe=1)
        $call set_netmod_fn
        &call mpidi_func, $(fn), $(params)
            $call safe_call, $(fn), $(args)
    $(for:fn in $(mpid_list))
        $call set_netmod_fn
        &call mpidi_func, $(fn), $(params)
            $call mpid_call, $(fn), $(args)
    $(for:fn in $(preq_list))
        $call set_netmod_fn
        &call mpidi_func, $(fn), $(params)
            $call pinit_call, $(fn), $(args)

    &call mpidi_func, cancel, $(params)
        $call cancel_call

