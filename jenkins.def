
include: macros_mymake/jenkins_old.def
include: macros_mymake/jenkins_new.def
include: macros_mymake/test_utils.def
output_dir: ./mymake

macros: 
    # test_worker: sh mymake/test-worker.sh
    test_worker: perl mymake/test_mymake.pl

page: jenkins.sh
    module: general

    $call @jenkins_old

page: slurm_job.sh
    module: general
    $call @slurm_job_old

#---------------------------------------- 
# For manual run from a scratch disk
page: run_pr
    module: perl

    $call set_mymake_dir
    $call checkout_pr
    $ENV{compiler}="gnu"
    $ENV{test_script}="test_quick"
    $ENV{skip_test}=1
    $ENV{config}="default"
    $if !$ENV{configOption}
        $ENV{configOption}="--enable-strict --disable-romio --disable-fortran"
    $ENV{SLURM_SUBMIT_HOST}=""
    $ENV{SLURM_SUBMIT_DIR}=""
    system "perl $mymake_dir/test_mymake.pl"

    subcode: checkout_pr
        my $pr=$ARGV[0]
        $if ! $pr > 0
            die "Usage: $0 pr-number\n"
        $call get_pr_info
        $if !$author
            die "Failed to fetch PR information\n"

        $if !-d "mpich-$pr"
            $call run, git clone https://github.com/pmodels/mpich mpich-$pr
            chdir "mpich-$pr" or die "Can't chdir mpich-$pr\n"
            $call run, git checkout -b $branch master
            $call run, git pull https://github.com/$author/mpich.git $branch
        $else
            chdir "mpich-$pr" or die "Can't chdir mpich-$pr\n"

    subcode: run(cmd)
        system("$(cmd)") == 0 or die "Error: $(cmd)\n"

    subcode: get_pr_info
        my ($author, $branch)
        &call open_r, curl https://api.github.com/repos/pmodels/mpich/pulls/$pr |
            $if /^\s*"label":\s*"(\w+):(\S+)",/
                $if $1 ne "pmodels"
                    $author = $1
                    $branch = $2
                    last
#---------------------------------------- 
page: test_mymake
    module: perl

    $call set_mymake_dir
    $global @mpich_config, @testmpi_config
    # my $compiler = $ENV{compiler}
    # my $queue = $ENV{queue}
    # my $config = $ENV{config}
    $call parse_config
    $call parse_trigger_phrase
    $call @set_missing_default
    $call filter_config
    $call set_N_MAKE_JOBS

    $call @dump_config

    my $time_start=time()
    my $ret = system "bash -xe $mymake_dir/$test_script.sh"
    my $time_finish=time()
    $if $ret
        $ret = $?>>8
    $else
        $call report_make_log

    $call @CollectResults

    exit $ret
    
    subcode: dump_config
        $print test_mymake.pl:
        $(for:mymake_dir,compiler,config,queue,mpich_config,testmpi_config,N_MAKE_JOBS,test_script,SLURM_SUBMIT_HOST,SLURM_SUBMIT_DIR)
            $print "    $1: $ENV{$1}"

    subcode: set_missing_default
        my $test_script = $ENV{test_script}
        $if !$test_script
            $test_script = "test_quick"  # or "test_build"

        $if !$ENV{compiler}
            $ENV{compiler}='gnu'

        $if !@mpich_config
            push @mpich_config, "--disable-fortran", "--disable-romio"

    subcode: parse_config
        my $config = $ENV{config}
        $config=~s/[\/-]/:/g
        $if $config=~/^(default|ch3:tcp)/
            NOOP
        $elif $config=~/^ch[34]/
            push @mpich_config, "--with-device=$config"
        $elif $config eq "stricterror"
            push @mpich_config, "--enable-strict=error"

    subcode: parse_trigger_phrase
        my $trigger_phrase = $ENV{ghprbCommentBody} . ' ' . $ENV{configOption}
        $while $trigger_phrase =~/(--(enable|disable|with|without)-\S+)/g
            push @mpich_config, $1


    subcode: report_make_log
        my @make_log
        $call parse_make_log
        my $n_fails = @make_log
        my $n_tests = $n_fails+1
        &call open_W, summary.junit.xml
            $print <testsuites>
            $print <testsuite failures="$n_fails" errors="0" skipped="0" tests="$n_tests" name="build">
            my $dur = $time_finish-$time_start
            $print <testcase name="1 - build" time="$dur"></testcase>
            my $i = 1
            $foreach $t in @make_log
                $i++
                $print <testcase name="$i">
                $print <failure message="$t"></failure>
                $print </testcase>
            $print </testsuite>
            $print </testsuites>

        subcode: parse_make_log
            &call open_r, make.log
                $if /^(\S+:\d+:\s*(error|warning):\s*.*)/
                    push @make_log, $1

    subcode: set_N_MAKE_JOBS
        my $n = 16
        $(if:0)
            my $cpu_count = `grep -c -P '^processor\\s+:' /proc/cpuinfo`
            $if $cpu_count=~/^(\d+)/
                $n= $1
        $ENV{N_MAKE_JOBS}=$n

    subcode: filter_config
        $if @mpich_config
            my (%config_hash)
            $foreach $t in @mpich_config
                my $k=$t
                $k=~s/=.*$//
                $k=~s/^--(disable|enable|with|without)-//
                $if $config_hash{$k}
                    $t=''
                    next
                $config_hash{$k}=1
                
                $if $t=~/--(disable|enable)-(.*-tests)/
                    push @testmpi_config, $t
                    $t=''
                    next

                $if $t=~/ch3:sock/
                    push @testmpi_config, "--disable-ft-tests"
                    push @testmpi_config, "--disable-comm-overlap-tests"
                    next

                $if $t=~/--disable-(romio|fortran)/
                    push @testmpi_config, $t

            # -----------------------------
            my $t = join(' ', @mpich_config)
            $if $t=~/gforker/ 
                $if $t!~/--with-namepublisher/
                    $t .= " --with-namepublisher=file"
                $else
                    $t=~s/--with-pm=gforker//
            $ENV{mpich_config}=$t

        push @testmpi_config, "--disable-ft-tests"
        push @testmpi_config, "--disable-perftest"
        $if @testmpi_config
            my $t=join ' ', @testmpi_config
            $ENV{testmpi_config} = $t

page: test_build.sh
    module: general

    &call test_frame
        git submodule update --init --recursive
        $call run, sh autogen.sh
        $call run, ./configure --prefix=$PREFIX $mpich_config
        $call run_make
        $call run, make install
        $call run, $MPIEXEC -n 2 examples/cpi

        &call test_testing
            cd test/mpi
            # $call run, sh autogen.sh
            # $call run, ./configure $testmpi_config
            make testing

page: test_quick.sh
    module: general

    &call test_frame
        $call copy_modules
        $call run, perl $mymake_dir/mymake.pl --prefix=$PREFIX $mpich_config
        $call run_make
        $call run, make install
        $call run_make, hydra
        $call run, make hydra-install

        &call test_testing
            $call run, make test

    subcode: copy_modules
        export MODDIR=$PWD/modules
        mkdir -p $MODDIR
        pushd $MODDIR
        tar xf $mymake_dir/modules.tar.gz
        $(if:1)
            pushd ucx
            make clean
            
        popd

page: build_modules.sh
    module: general

    uname -a

    git clone https://github.com/pmodels/hwloc
    git clone https://github.com/pmodels/izem
    git clone https://github.com/pmodels/ucx
    git clone https://github.com/ofiwg/libfabric

    $call config, hwloc, --enable-embedded-mode --enable-visibility
    $call config, izem, --enable-embedded
    $call config, ucx, --disable-shared --with-pic
    $call config, libfabric, --enable-embedded

    tar czf modules.tar.gz hwloc izem ucx libfabric

    subcode: config(dir, option)
        cd $(dir)
        $(if:dir=ucx)
            mkdir -p config/m4 config/aux
            autoreconf -iv
        $(else)
            sh autogen.sh
        ./configure $(option)
        make -j 16
        cd ..

#---------------------------------------- 
subcode: test_frame
    $call test_prepare
    set -o pipefail
    BLOCK

    subcode: run(cmd)
        $(cmd) 2>&1 || exit 1

    subcode: run_make(@target)
        make -j$N_MAKE_JOBS $(target) 2>&1 | tee -a make.log
        if test "$?" != "0"; then
            exit $?
        fi

    subcode: mult_call(proc)
        if test -n $jenkins_old ; then
            $call $(proc)_old
        else
            $call $(proc)
        fi
    subcode: test_prepare
        $call pre_check
        $call mult_call, PrepareEnv
        if test -d $HOME/software/autotools/bin; then
            export PATH=$HOME/software/autotools/bin:$PATH
        fi

        if test -n $compiler ; then
            $call mult_call, SetCompiler
        fi
        $(for:autoconf,automake,libtool)
            which $1
            $1 --version
        $(for:CC,CXX,F77,FC)
            export $1
            which $$1
            $$1 --version
        WORKSPACE=$PWD
        SRC=$PWD
        # $call prepare_from_tarball
        PREFIX=$WORKSPACE/_inst
        MPIEXEC=$PREFIX/bin/mpiexec

        subcode: pre_check
            hostname
            date
            uptime
            pgrep mpiexec | wc -l

    subcode: test_testing
        if test x$skip_test = x1 ; then 
            exit 0
        else
            export PATH=$PREFIX/bin:$PATH
            export CPATH=$PREFIX/include:$CPATH
            export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH
            BLOCK
        fi

#---------------------------------------- 
subcode: set_mymake_dir
    my $mymake_dir = $ENV{mymake_dir}
    $if ! $mymake_dir
        $if $0=~/^(\/.*)\//
            $mymake_dir = $1
        $elif $0=~/^(.*)\//
            my $pwd=`pwd`
            chomp $pwd
            $mymake_dir .= "$pwd/$1"
        $ENV{mymake_dir}=$mymake_dir

