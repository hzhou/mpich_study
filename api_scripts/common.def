macros:
    OUTDIR: .
    standard_dir: /home/hzhou/work/mpi-standard
    orig_mpich_dir: /home/hzhou/work/pull_requests/branch-2010_mpi_gen
    mpich: /home/hzhou/work/mpich-github
    standard_api_txt: maint/mpi_standard_api.txt

subcode: load_api(@custom_list)
    $(if:do_sync)
        $(set:mpich=.)
    load_mpi_api("$(mpich)/$(standard_api_txt)")
    $(for:f in $(custom_list))
        load_mpi_api("$(mpich)/src/mpi/$(f)/mpi_$(f)_api.txt")

subcode: _autoload
    $global %FUNCS, %MAPS, %default_descriptions

#---------------------------------------- 
fncode: load_mpi_api($api_txt)
    my $see_also_idx=0
    my ($cur_func, $cur_map, $cur_name)
    my $stage = ''
    &call open_r, $api_txt
        $if /^(MPI\w+):\s*(.*)/ -> $name, $attr
            $stage = "FUNC"
            $cur_name = $name
            $if exists $FUNCS{$name}
                $cur_func = $FUNCS{$name}
                $if $attr
                    $cur_func->{attrs} = $attr
            $else
                $cur_func = {name=>$name, params=>[], attrs=>$attr}
                $FUNCS{$name} = $cur_func
        $elif /^(\w+_KIND_MAP):/ -> $name
            $stage = "MAP"
            $cur_name = $name
            $cur_map = {_name=>$name}
            $MAPS{$name} = $cur_map
        $elif /^Default Descriptions/
            $stage = "default_descriptions"
            $cur_name = "Default Descriptions"
        $elif $stage eq "FUNC"
            $if /^\s+\.(\w+):\s*(.*)/ -> $key, $val
                $cur_func->{$key} = $val
            $elif /^\s+(\w+):\s*(\w+)(.*)/ -> $name, $kind, $t
                my $p={name=>$name, kind=>$kind}
                $if $t=~/^(.*),\s*\[(.*)\]\s*$/ -> $t*, $p->{desc}*
                    # NOOP
                $p->{t} = $t
                push @{$cur_func->{params}}, $p
            $elif /^{/
                $stage = "FUNC-body"
                $if !exists $cur_func->{body}
                    $cur_func->{body} = []
            $elif /^\/\*/
                $stage = "FUNC-notes"
                $if !exists $cur_func->{notes}
                    $cur_func->{notes} = []
        $elif $stage eq "MAP"
            $if /^\s+\.base:\s*(\w+)/ -> $name
                %$cur_map = %{$MAPS{$name}}
                $cur_map->{_name} = $cur_name
                $MAPS{$cur_name} = $cur_map
            $elif /^\s+(\w+):\s*(.*)/ -> $name, $param_type
                $cur_map->{$name} = $param_type
        $elif $stage eq "default_descriptions"
            $if /^\s*(\w+):\s*(.*)/ -> $key, $val
                $default_descriptions{$key} = $val
        $elif $stage eq "FUNC-body"
            $if /^}/
                $stage = "FUNC"
            $else
                push @{$cur_func->{body}}, $_
        $elif $stage eq "FUNC-notes"
            $if /^\*\//
                $stage = "FUNC"
            $else
                s/^    //
                push @{$cur_func->{notes}}, $_

#---------------------------------------- 
fncode: get_C_params($func, $mapping)
    my @param_list
    $foreach $p in @{$func->{params}}
        push @param_list, get_C_param($p, $mapping)
    $if !@param_list
        return ["void"]
    $else
        return \@param_list

fncode: get_C_param($param, $mapping)
    my $kind = $param->{kind}
    $if $kind eq "VARARGS"
        return "..."

    $call get_param_type
    $call check_want_star

    my $s
    $if $param->{t}=~/constant=True/
        $s.="const "
    $s.=$param_type

    $if $want_star
        $s.=" *"
        $(if:style!=succinct)
            $if $s!~/\b(void|int|char|size_t)\b/
                $s.=" "
    $else
        $s.=" "
    $s.=$param->{name}

    $if $want_bracket
        $s.="[]"
    $if $param->{t}=~/length=\[.*?, (\d+)\]/ -> $n
        $s.="[$n]"

    return $s

    # -----------------------------
    subcode: get_param_type
        my $param_type = $mapping->{$kind}
        $if $kind eq "FUNCTION"
            $if $param->{t}=~/func_type=(\w+)/ -> $param_type*
                NOOP
            $else
                $die Function type for parameter $param->{name} not found!
        $if !$param_type
            $die Type mapping [$mapping] $kind not found!

    subcode: check_want_star
        my $t = $param->{t}
        my ($want_star, $want_bracket)
        $if $kind=~/^ATTRIBUTE_VAL(_10)?$/
            $want_star = 1
        $elif $kind eq "STRING"
            $if $t=~/length=/ and $t!~/pointer=/
                $want_bracket = 1
            $else
                $want_star = 1
        $elif $kind=~/^STRING_(2D)?ARRAY$/
            $want_bracket = 1
        $elif $kind=~/^((C_)?BUFFER\d?|STRING|EXTRA_STATE|FUNCTION)$/
            $want_star = 1
        $elif $t=~/direction=(in)?out|pointer=/ and $t!~/length=/
            $want_star = 1

fncode: is_pointer_type($kind, $t)
    $if $kind=~/^ATTRIBUTE_VAL(_10)?$/
        return 1
    $elif $kind eq "STRING"
        return 1
    $elif $kind=~/^STRING_(2D)?ARRAY$/
        return 1
    $elif $kind=~/^((C_)?BUFFER\d?|STRING|EXTRA_STATE|FUNCTION)$/
        return 1
    $elif $t=~/direction=(in)?out|pointer=/ and $t!~/length=/
        return 1
    $else
        return 0

#---- dump utils ------------------------------------ 
subcode: copy_right
    $print "/*"
    $print " * Copyright (C) by Argonne National Laboratory"
    $print " *     See COPYRIGHT in top-level directory"
    $print " */"
    $print

subcode: begin_error_checking
    $print "#ifdef HAVE_ERROR_CHECKING"
    $print "    {"
    $print "        MPID_BEGIN_ERROR_CHECKS;"
    $print "        {"
    my $sp = ' ' x 12;
    BLOCK
    $print "        }"
    $print "        MPID_END_ERROR_CHECKS;"
    $print "    }"
    $print "#endif \x2f* HAVE_ERROR_CHECKING */"
