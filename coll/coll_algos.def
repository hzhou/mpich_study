fncode: MPIR_Allgather_intra_brucks
    &call collective_frame
        $call brucks, allgather

subcode: brucks(coll)
    $if sendcount == 0 && sendbuf!=MPI_IN_PLACE
        return MPI_SUCCESS

    $(if:coll=allgather)
        $(set:total_count=recvcount * comm_size)
    $(elif:coll=allgatherv)
        $for i=0:comm_size
            total_count += recvcounts[i]
        $(set:total_count=total_count)

    $if $(total_count)==0
        return MPI_SUCCESS

    MPIR_Datatype_get_extent_macro(recvtype, recvtype_extent)
    MPIR_Type_get_true_extent_impl(recvtype, &recvtype_true_lb, &recvtype_true_extent)
    $(set:extent=MPL_MAX(recvtype_true_extent, recvtype_extent))
    MPIR_Ensure_Aint_fits_in_pointer(MPIR_VOID_PTR_CAST_TO_MPI_AINT recvbuf+($(total_count)*$(extent)))
    recvbuf_extent = $(total_count) * $(extent)
    MPIR_CHKLMEM_MALLOC(tmp_buf, void *, recvbuf_extent, mpi_errno, "tmp_buf", MPL_MEM_BUFFER)
    # adjust for potential negative lower bound
    tmp_buf = (void*)((char*)tmp_buf - recvtype_true_lb)
    $call local_to_tmp_buf
    $call phase2
    $call local_rotate_down
    
    subcode: local_to_tmp_buf
        $(set:send=sendbuf, sendcount, sendtype)
        $(set:tmp =tmp_buf, recvcount, recvtype)
        $if sendbuf == MPI_IN_PLACE
            $fcall MPIR_Localcopy((char*)recvbuf+rank*recvcount*recvtype_extent, recvcount, recvtype, $(tmp))
        $else
            $fcall MPIR_Localcopy($(send), $(tmp))

fncode: MPIR_Allgather_intra_recursive_doubling

#---- Common ------------------------------------ 
subcode: collective_frame
    comm_size = comm_ptr->localsize
    rank = comm_ptr->rank

